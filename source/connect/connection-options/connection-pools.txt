.. _golang-connection-pools:

================
Connection Pools
================

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

.. facet::
   :name: genre
   :values: reference

Overview
--------

In this guide, you can learn about how the {+driver-short+} uses connection
pools to manage connections to a MongoDB deployment and how you can configure
connection pool settings in your application.

A connection pool is a cache of open database connections maintained by the
{+driver-short+}. When your application requests a connection to MongoDB, the
{+driver-short+} seamlessly gets a connection from the pool, performs
operations, and returns the connection to the pool for reuse.

Connection pools help reduce application latency and the number of times new
connections are created by {+driver-short+}.

.. _golang-faq-connection-pool:

Create a Connection Pool
------------------------

Every ``Client`` instance has a built-in connection pool for each server in your
MongoDB topology. If you do not configure the ``minPoolSize`` option, connection
pools open sockets on demand. These sockets support concurrent MongoDB
operations, or `goroutines <https://go.dev/tour/concurrency/1>`__, in
your application.

Each ``Client`` instance opens two more sockets per server in your MongoDB
topology for monitoring the server's state. 

For example, a client connected to a three-node replica set opens six monitoring
sockets. If the application uses the default setting for ``maxPoolSize`` and
only queries the primary (default) node, then there can be at most ``106`` open
sockets and ``100`` connections in the connection pool. If the application uses
a :ref:`read preference <golang-read-pref>` to query the secondary nodes, their
pools also grow and there can be ``306`` total connections.

Create a client once for each process, and reuse it for all operations. Avoid
creating a new client for each request, as this is inefficient.

Configure a Connection Pool
---------------------------

You can specify settings for your connection pool either by using a connection
string with the ``options.Client().ApplyURI()`` method.

The following are connection string settings you can use to configure your
connection pool:

.. list-table::
   :widths: 25,75                                                          
   :header-rows: 1

   * - Setting
     - Description
         
   * - ``maxPoolSize``

     - Maximum number of connections opened in the pool. If an operation needs a
       new connection while the connection pool has ``maxPoolSize`` connections
       open, the new operation waits for a new connection to open. To limit this
       waiting time, use the single timeout setting.

       *Default:* ``100`` 

   * - ``minPoolSize``

     - Minimum number of connections opened in the pool. The value of
       ``minPoolSize`` must be less than the value of ``maxPoolSize``.

       *Default*: ``0``

   * - ``maxConnecting``
         
     - Maximum number of connections a pool may establish concurrently.
            
       *Default:* ``2``
         
   * - ``maxIdleTimeMS``
         
     - The maximum number of milliseconds that a connection can remain idle in
       the pool before being removed and closed.

       *Default:* ``None`` (no limit)

   * - ``waitQueueTimeoutMS```

     - Specifies the maximum wait time in milliseconds that a thread can wait
       for a connection to become available.

       *Default*: ``0`` (no limit)

The following code creates a client with a maximum connection pool size of
``50``, a minimum pool size of ``10``, and a maximum idle time of
``30000`` milliseconds (30 seconds):

.. literalinclude:: /includes/connect/connection-pools-uri.go
   :language: go
   :start-after: start-connection-pool-uri
   :end-before: end-connection-pool-uri
   :dedent:

Optimize Connection Pools
-------------------------

Connection pools are rate-limited such that each connection pool can only create,
at maximum, the value of ``maxConnecting`` connections in parallel at any time.
Any new goroutine stops waiting in the following cases:

- One of the existing goroutines finishes creating a connection, or an existing
  connection is checked back into the pool.
- The driver's ability to reuse existing connections improves due to rate-limits
  on connection creation.

The driver does not limit the number of operations that can wait for sockets to
become available and it is the application's responsibility to limit the size of
its pool to bound queuing during a load spike. Operations can wait for any length of time
unless you define the ``waitQueueTimeoutMS`` option.

An operation that waits more than the length of time defined by
``waitQueueTimeoutMS`` for a socket raises a connection error. Use this option
if it is more important to bound the duration of operations during a load spike
than it is to complete every operation.

Disconnecting
-------------

When you call ``Client.Disconnect()`` from any goroutine, the driver closes all
idle sockets and closes all sockets in use as they are returned to the pool.

Additional Information
----------------------

For more information on using a connection pool, see the :manual:`Connection
Pool </administration/connection-pool-overview>` documentation in the Server
manual. 

API Documentation
~~~~~~~~~~~~~~~~~

To learn more about any of the methods or types discussed in this
guide, see the following API documentation:

- `Client <{+api+}/mongo#Client>`__
- `Client.Diconnect() <{+api+}/mongo#Client.Disconnect>`__